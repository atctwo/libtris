This is a kind of library that attempts to provide a portable Tetris engine. If you want to get Tetris running on something, but you don\textquotesingle{}t want to write the game logic, you could use this library so that you only have to build a frontend for the game. The library consists of a single header file, which provides a class, which provides methods you can use to interact with the game. Included is an example of how the engine could be used to create a Tetris clone using \href{https://www.raylib.com/}{\texttt{ raylib}}.\hypertarget{md_readme_autotoc_md1}{}\doxysection{Todo}\label{md_readme_autotoc_md1}

\begin{DoxyItemize}
\item that\textquotesingle{}s total garbage! + garbage out and top out
\item anticlockwise rotation
\item rotation at the bottom of the matrix
\item back to back and t-\/spin
\item methods for getting game stats (like number of combos, L\+PM, etc)
\end{DoxyItemize}\hypertarget{md_readme_autotoc_md2}{}\doxysection{Tetris Guidelines}\label{md_readme_autotoc_md2}
There is a document that specifies how official Tetris games should be implemented, and a lot of is documentated online (for example, at \href{https://tetris.wiki/Tetris_Guideline}{\texttt{ this Tetris Wiki}}). Here is a quick run through of what parts of the Guidelines libtris implements, and what needs to be implemented when writing a frontend.\hypertarget{md_readme_autotoc_md3}{}\doxysubsection{Logo}\label{md_readme_autotoc_md3}
libtris doesn\textquotesingle{}t make use of the Tetris logo (it\textquotesingle{}s not an official Tetris game), it\textquotesingle{}s probably protected by lots of legal stuff\hypertarget{md_readme_autotoc_md4}{}\doxysubsection{Super Rotation System (sometimes called S\+R\+S)}\label{md_readme_autotoc_md4}
libtris (mostly) implements this entirely within the library, so you don\textquotesingle{}t have to do anything. The tetrimino rotations aren\textquotesingle{}t exactly the same as required by S\+RS. Wall kick can be disabled by using the {\ttfamily enable\+Wall\+Kick()} method.\hypertarget{md_readme_autotoc_md5}{}\doxysubsection{Tetrimino starting positions}\label{md_readme_autotoc_md5}
The starting position (and matrix size) are specified by the user when a libtris object is instantiated. The guidelines specify that tetriminoes spawn on rows 21 and 22. The raylib example implements this.\hypertarget{md_readme_autotoc_md6}{}\doxysubsection{Lock Down}\label{md_readme_autotoc_md6}
At the minute, lock down is pretty simple. A tetrimino locks down when it would otherwise move down a cell, but there is something directly underneath that means the tetrimino can\textquotesingle{}t move down. A more advanced lock down will be implemented soon i think.\hypertarget{md_readme_autotoc_md7}{}\doxysubsection{Hold}\label{md_readme_autotoc_md7}
Hold isn\textquotesingle{}t implemented yet.\hypertarget{md_readme_autotoc_md8}{}\doxysubsection{Piece preview}\label{md_readme_autotoc_md8}
You can preview up to the next six pieces that will be spawned by using the {\ttfamily get\+Next\+Blocks()} method.\hypertarget{md_readme_autotoc_md9}{}\doxysubsection{Playfield (sometimes called matrix)}\label{md_readme_autotoc_md9}
It\textquotesingle{}s up to the user to determine the size of the playfield. The guidelines specify that the playfield should be 10x20, with an extra 20 cell tall buffer zone above the playfield. To acheive the buffer zone, you can tell the library to create a playfield that is 10x40, and that the first 20 rows are buffer rows. You can get the width and height of the playfield using {\ttfamily get\+Matrix\+Width()} and {\ttfamily get\+Matrix\+Height()}, and you can get the size of the playfield that should be visible (not buffer space) by using {\ttfamily get\+Visible\+Matrix\+Height()}.\hypertarget{md_readme_autotoc_md10}{}\doxysubsection{Piece colours}\label{md_readme_autotoc_md10}
Because the datatype that represents colour is provided by the user, the user also has to specify the colours of each piece (and each piece ghost) when initalising a libtris object.\hypertarget{md_readme_autotoc_md11}{}\doxysubsection{Random Generator}\label{md_readme_autotoc_md11}
Tetriminoes aren\textquotesingle{}t randomly generated one after the other. The game kind of puts each of the tetriminoes into a bag, then shuffles the bag, so you will always get the same set of tetriminoes but in a different order. The library uses two \char`\"{}bags\char`\"{} so that you can get previews of the next pieces, so if you need to know what piece will be spawned outside of the bag, you can find out. my words are {\itshape very} messed up, i am tired \+:)\hypertarget{md_readme_autotoc_md12}{}\doxysubsection{Ghost piece}\label{md_readme_autotoc_md12}
The library includes a ghost piece system, which can be enabled or disabled by calling {\ttfamily enable\+Ghost()}.\hypertarget{md_readme_autotoc_md13}{}\doxysubsection{Controller mappings}\label{md_readme_autotoc_md13}
The controller mappings aren\textquotesingle{}t handled by the library, and have to be implemented by the user.\hypertarget{md_readme_autotoc_md14}{}\doxysubsection{Timings}\label{md_readme_autotoc_md14}
The game timings are handled by the library, and are based on the ones used in Tetris Worlds. The library has an {\ttfamily update()} method, to which you have to pass a value called \char`\"{}delta time\char`\"{}, which is the time that the last frame took to render (i think). You can set D\+AS, A\+RR, and A\+RE by using {\ttfamily set\+D\+A\+S()}, {\ttfamily set\+A\+R\+R()}, and {\ttfamily set\+A\+R\+E()}.\hypertarget{md_readme_autotoc_md15}{}\doxysubsection{Levels and Scoring}\label{md_readme_autotoc_md15}
The library handles levels and scoring. The scoring system is based on the one that is used by most games released after Tetris DS (described \href{https://tetris.wiki/Scoring\#Recent_guideline_compatible_games}{\texttt{ here}}). The level is determined by clearing lines. To level up, you need to clear a number of lines that can be determined by multiplying the current level by 5. Combos have been implemented, but T-\/\+Spins and Back-\/to-\/\+Backs haven\textquotesingle{}t. The user can set the level using {\ttfamily set\+Level()}.\hypertarget{md_readme_autotoc_md16}{}\doxysubsection{Music}\label{md_readme_autotoc_md16}
The library doesn\textquotesingle{}t include any music (or sound effects).\hypertarget{md_readme_autotoc_md17}{}\doxysubsection{Game over conditions}\label{md_readme_autotoc_md17}
There aren\textquotesingle{}t any game over conditions yet.\hypertarget{md_readme_autotoc_md18}{}\doxysubsection{Garbage}\label{md_readme_autotoc_md18}
There is no multiplayer mode, so there is no garbage system. In saying that, there\textquotesingle{}s nothing stopping you creating two instances of libtris, so having a garbage method might be a good idea.\hypertarget{md_readme_autotoc_md19}{}\doxysubsection{T-\/\+Spin detection}\label{md_readme_autotoc_md19}
I haven\textquotesingle{}t done this yet!! haha! 